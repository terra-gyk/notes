## 4.3 死信队列

![image-20250307162916010](image\image-20250307162916010.png)

- 以下是关于DLX（Dead-Letter-Exchange，死信交换器）的详细解释：
- DLX，全称为 **Dead-Letter-Exchange**，可以称之为死信交换器，也有人称之为死信邮箱。当消息在一个队列中变成死信（dead message）之后，它能被重新被发送到另一个交换器中，这个交换器就是DLX，绑定DLX的队列就称之为死信队列。
- 消息变成死信一般是由以下几种情况：
  - 消息被拒绝（Basic.Reject/Basic.Nack），并且设置 `requeue` 参数为 `false`；
  - 消息过期；
  - 队列达到最大长度。
- DLX也是一个正常的交换器，和一般的交换器没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。当这个队列中存在死信时，RabbitMQ就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到另一个队列，即死信队列。可以监听这个队列中的消息以进行相应的处理，这个特性与将消息的TTL设置为0配合使用可以弥补immediate参数的功能

- 总结

  - **DLX** 是一种特殊的交换器，用于处理无法正常消费的消息。

  - **死信队列** 是绑定到DLX的队列，用于接收这些无法正常消费的消息。

  - **应用场景** 包括消息被拒绝、消息过期或队列达到最大长度等情况。

- 通过这种方式，可以有效地管理和处理那些无法正常消费的消息，确保系统的健壮性和可靠性。

## 4.4 延迟队列

![image-20250307162947696](image\image-20250307162947696.png)

- 延迟队列存储的对象是对应的延迟消息，所谓”延迟消息“是指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。
- DLX 配合 TTL 使用可以实现延迟队列的功能。
- 场景：
  - 订单系统，30分钟的支付时间。
  - 遥控系统，比如智能家居在指定的时间工作。

## 4.5 优先级队列

- 优先级队列，具有高优先级的队列具有高的优先权，优先级高的消息具备优先被消费的特权。
- 可以通过设置队列的x-max-priority参数来实现

## 4.6 RPC 实现

- pass

## 4.7 持久化

- 交换器的持久化
  - 交换器的持久化是通过在声明队列时将 `durable` 参数置为 `true` 实现的。详细可以参考3.2.1节。如果交换器不设置持久化，那么在RabbitMQ服务重启之后，相关的交换器元数据会丢失，不过消息不会丢失，只是不能将消息发送到这个交换器中了。对一个长期使用的交换器来说，建议将其置为持久化的。

- 队列的持久化
  - 队列的持久化是通过在声明队列时将 `durable` 参数置为 `true` 实现的，如果队列不设置持久化，那么在RabbitMQ服务重启之后，相关队列的元数据会丢失，此时数据也会丢失。

- 消息的持久化
  - 队列的持久化能保证其本身的元数据不会因异常情况而丢失，但是并不能保证内部所存储的消息不会丢失。要确保消息不会丢失，需要将其设置为持久化。通过将消息的投递模式（BasicProperties中的`deliveryMode`属性）设置为2即可实现消息的持久化。前面示例中多次提及的`MessageProperties.PERSISTENT_TEXT_PLAIN`实际上是封装了这个属性。
- 全部设置为持久化，并不能保证消息完全不会丢失，如果要保证消息的完整性，最好还是主备部署

## 4.8 生产者确认

- 生产者无法知道消息是否被投递到消息队列中

### 4.8.1 事务机制

- RabbitMQ 客户端中与事务机制相关的方法有三个：`channel.txSelect`、`channel.txCommit` 和 `channel.txRollback`。`channel.txSelect` 用于将当前的信道设置成事务模式，`channel.txCommit` 用于提交事务，`channel.txRollback` 用于事务回滚。

- 在通过 `channel.txSelect` 方法开启事务之后，我们便可以发布消息给 RabbitMQ 了，如果事务提交成功，则消息一定到达了 RabbitMQ 中；如果在事务提交执行之前由于 RabbitMQ 异常崩溃或者其他原因抛出异常，这个时候我们便可以将其捕获，进而通过执行 `channel.txRollback` 方法来实现事务回滚。注意这里的 RabbitMQ 中的事务机制与大多数数据库中的事务概念并不相同，需要注意区分。

### 4.8.2 发送方确认机制

![image-20250307164505465](image\image-20250307164505465.png)

- 生产者将信道设置成 `confirm`（确认）模式，一旦信道进入 `confirm` 模式，所有在该信道上面发布的消息都会被指派一个唯一的 ID（从 1 开始），一旦消息被投递到所有匹配的队列之后，RabbitMQ 就会发送一个确认（Basic.Ack）给生产者（包含消息的唯一 ID），这就使得生产者知晓消息已经正确到达了目的地了。如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。RabbitMQ 回传给生产者的确认消息中的 `deliveryTag` 包含了确认消息的序号。此外 RabbitMQ 也可以设置 `channel.basicAck` 方法中的 `multiple` 参数，表示到这个序号之前的所有消息都已经得到了处理，可以参考图 4-10。注意辨别这里的确认和消费时候的确认之间的异同。













