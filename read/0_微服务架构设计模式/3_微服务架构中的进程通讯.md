## 3.1 微服务架构中的进程间通信概述

- 基于同步请求/响应的通信机制：htpp rest 或者 gRPC
- 异步的基于消息的通信机制，消息队列 or TCP通讯

### 3.1.1 交互方式

- 一对一：每个客户端请求由一个服务实例来处理
- 一对多：每个客户端请求由多个服务实例来处理
- 同步模式：客户端请求需要服务端实时响应，等待可能导致客户端阻塞
- 异步模式：非实时响应，客户端不会阻塞

![image-20250228101230677](image\image-20250228101230677.png)

- 一对一的交互方式：
  - 请求/响应：响应快，可能阻塞，紧耦合
  - 异步请求/响应：响应没那么快
  - 单向通知：无响应，无法感知服务是否收到
- 一对多的交互方式：
  - 发布/订阅方式：可以被多个服务订阅，不一定返回
  - 发布/异步响应方式：客户端发布，等待感兴趣服务返回

### 3.1.2 在微服务架构中定义API

- API 是软件开发的中心。应用是由模块构成的，每个模块都有接口，这些接口定义了模块的客户端可以调用若干操作。一个设计良好的接口会在暴露有用功能的同时隐藏实现细节。细节可以被修改，而接口保持不变。
- 如何定义API取决于你使用的进程通讯机制。例如，如果你正在使用消息机制，则API由消息通道、消息类型和消息格式组成。如果使用HTTP，则API由URL、HTTP动词以及请求和响应格式组成。

### 3.1.3 API的演化

- API不可避免地会随着应用功能地增减而发生变化。
- 进行次要并且向后兼容的改变
  - 老版本客户端可以直接使用
- 进行主要并且不向后兼容的改变
  - 客户端可能无法同时升级，因此需要保留对旧版本API的支持

### 3.1.4 消息的格式

- 进程间通信的本质是交换消息。
- 基于文本的消息格式：可读性好，相对比较冗长
- 二进制消息格式：Protocal Buffers，编译器会自动生产序列化和反序列化的代码



## 3.2 基于同步远程过程调用模式的通信

客户端发送请求，服务处理该请求并发回响应。

###  3.2.1 使用REST

- 使用HTTP协议的进程间通讯机制
- 好处：
  - 简单，易于测试。
  - 直接支持请求/响应的模式
  - 防火墙友好，不需要中间代理
- 弊端：
  - 只支持请求/响应模式
  - 没有中间缓存，调用期间服务与客户端必须都在线
  - 必须使用服务发现机制
  - 请求多个资源时，需要多次调用

### 3.2.2 使用gRPC

- gRPC AI由一个或多个服务和请求/响应消息定义组成
- 好处：
  - 高效，紧凑，适合交换大量消息
  - 使用双向流式消息方式
  - 各种编程语言之间可以互通
- 弊端：
  - 写起来很麻烦
  - 防火墙可能不支持http2

### 3.2.3 使用断路器模式处理局部故障

- 客户端等待响应被阻塞，如服务一直无响应，则可能导致客户端处于不可用状态
- 处理方式：
  - 增加网络超时
  - 限制客户端向服务器发出请求的数量（超过数量立即失败）
  - 断路器模式：监控请求成功和失败的数量，如果失败的比例超过一定的阈值，就启动断路器，让后续的调用立刻失败

### 3.2.4 使用服务发现

- 使用远程调用，不论是HTTP或者gRPC都需要知道服务地址。（by the way 是否可以使用 nginx 来做负载均衡，如果是HTTP的话）
- consul 这个比较简单方便，zookeeper太重了

## 3.3 基于异步消息模式的通信

- 使用消息代理，比如消息队列
- 直接发送消息来执行服务请求，服务侧向客户端发送单独的消息方式来回复，此时也是异步的

### 3.3.1 什么是消息传递

- 消息通过消息通道进行交换。发送方将消息写入通道，接收方从通道中读取消息
- 消息：各种，tcp，http，rpc等等
- 通道：点对点通道， 发布 - 订阅











