## 3.1 微服务架构中的进程间通信概述

- 基于同步请求/响应的通信机制：htpp rest 或者 gRPC
- 异步的基于消息的通信机制，消息队列 or TCP通讯

### 3.1.1 交互方式

- 一对一：每个客户端请求由一个服务实例来处理
- 一对多：每个客户端请求由多个服务实例来处理
- 同步模式：客户端请求需要服务端实时响应，等待可能导致客户端阻塞
- 异步模式：非实时响应，客户端不会阻塞

![image-20250228101230677](image\image-20250228101230677.png)

- 一对一的交互方式：
  - 请求/响应：响应快，可能阻塞，紧耦合
  - 异步请求/响应：响应没那么快
  - 单向通知：无响应，无法感知服务是否收到
- 一对多的交互方式：
  - 发布/订阅方式：可以被多个服务订阅，不一定返回
  - 发布/异步响应方式：客户端发布，等待感兴趣服务返回

### 3.1.2 在微服务架构中定义API

- API 是软件开发的中心。应用是由模块构成的，每个模块都有接口，这些接口定义了模块的客户端可以调用若干操作。一个设计良好的接口会在暴露有用功能的同时隐藏实现细节。细节可以被修改，而接口保持不变。
- 如何定义API取决于你使用的进程通讯机制。例如，如果你正在使用消息机制，则API由消息通道、消息类型和消息格式组成。如果使用HTTP，则API由URL、HTTP动词以及请求和响应格式组成。

### 3.1.3 API的演化

- API不可避免地会随着应用功能地增减而发生变化。
- 进行次要并且向后兼容的改变
  - 老版本客户端可以直接使用
- 进行主要并且不向后兼容的改变
  - 客户端可能无法同时升级，因此需要保留对旧版本API的支持

### 3.1.4 消息的格式

- 进程间通信的本质是交换消息。
- 基于文本的消息格式：可读性好，相对比较冗长
- 二进制消息格式：Protocal Buffers，编译器会自动生产序列化和反序列化的代码



## 3.2 基于同步远程过程调用模式的通信

客户端发送请求，服务处理该请求并发回响应。

###  3.2.1 使用REST

- 使用HTTP协议的进程间通讯机制
- 好处：
  - 简单，易于测试。
  - 直接支持请求/响应的模式
  - 防火墙友好，不需要中间代理
- 弊端：
  - 只支持请求/响应模式
  - 没有中间缓存，调用期间服务与客户端必须都在线
  - 必须使用服务发现机制
  - 请求多个资源时，需要多次调用

### 3.2.2 使用gRPC

- gRPC AI由一个或多个服务和请求/响应消息定义组成
- 好处：
  - 高效，紧凑，适合交换大量消息
  - 使用双向流式消息方式
  - 各种编程语言之间可以互通
- 弊端：
  - 写起来很麻烦
  - 防火墙可能不支持http2

### 3.2.3 使用断路器模式处理局部故障

- 客户端等待响应被阻塞，如服务一直无响应，则可能导致客户端处于不可用状态
- 处理方式：
  - 增加网络超时
  - 限制客户端向服务器发出请求的数量（超过数量立即失败）
  - 断路器模式：监控请求成功和失败的数量，如果失败的比例超过一定的阈值，就启动断路器，让后续的调用立刻失败

### 3.2.4 使用服务发现

- 使用远程调用，不论是HTTP或者gRPC都需要知道服务地址。（by the way 是否可以使用 nginx 来做负载均衡，如果是HTTP的话）
- consul 这个比较简单方便，zookeeper太重了

## 3.3 基于异步消息模式的通信

- 使用消息代理，比如消息队列
- 直接发送消息来执行服务请求，服务侧向客户端发送单独的消息方式来回复，此时也是异步的

### 3.3.1 什么是消息传递

- 消息通过消息通道进行交换。发送方将消息写入通道，接收方从通道中读取消息
- 消息：各种，tcp，http，rpc等等
- 通道：点对点通道， 发布 - 订阅

### 3.3.2 使用消息机制实现交互方式

![image-20250507155638375](image\image-20250507155638375.png)

- 实现请求/响应和异步请求/响应
  - 客户端发送具有回复通道头部的命令式消息。
  - 服务器将回复性消息写入回复通道，该回复消息包含与消息标识符具有相同值的相关性ID。
  - 客户端使用相关性ID将回复消息与请求进行匹配。
- 实现单向通知
  - 客户端将消息发送到服务所拥有的点对点通道。
  - 服务订阅该通道并处理该消息，但是服务不会发回回复。
- 实现发布/订阅
  - 客户端将消息发布到由多个接收方读取的发布-订阅通道。
  - 服务使用发布-订阅来发布领域事件，领域事件代表领域对象的更改。
  - 发布领域事件的服务拥有自己的发布-订阅通道，通道的名称往往派生自领域类。
  - 对特定领域对象的事件感兴趣的服务只需订阅相应的通道。
- 实现发布/异步响应
  - 客户端发布一条消息，在消息的头部中指定回复通道，这个通道同时也是一个发布-订阅通道。
  - 消费者将包含相关性ID的回复消息写入回复通道。
  - 客户端通过使用相关性ID来收集响应，以此将回复消息与请求进行匹配。

### 3.3.3 为基于消息机制的服务API创建API规范

- 服务的异步API规范必须指定消息通道的名称、通过每个通道交换的消息类型及其格式。
- ![image-20250507162823213](image\image-20250507162823213.png)

### 3.3.4 使用消息代理

- 无代理消息
  - 服务直接交换消息。
- 基于代理的消息
  - ActiveMQ
  - RabbitMQ
  - Kafka
- 基于代理的消息的好处和弊端
  - 好处：
    - 松耦合
    - 消息缓存
    - 灵活的通信
    - 明确的进程间通讯
  - 弊端：
    - 潜在的性能瓶颈
    - 潜在的单点故障
    - 额外的操作复杂性

### 3.3.5 处理并发和消息顺序

- 现代消息代理使用的常见解决方案是使用分片（分区）通道。
  1. 分片通道由两个或多个分片组成，每个分片的行为类似于一个通道。
  2. 发送方在消息头部指定分片键，通常是任意字符串或者字节序列。消息代理使用分片键将消息分配给特定的分片。例如，它可以通过计算分片键的散列来选择分片。
  3. 消息代理将接收方的多个实例组合在一起，并将它们视为相同的逻辑接收方。

![image-20250508091006384](image\image-20250508091006384.png)

- 上述示例中，每个Order事件消息都将orderID作为其分片键。特定订单的每个事件都发布到同一个分片上，而且该分片中的消息始终由同一个接收方实例读取。

### 3.3.6 处理重复消息

- 编写幂等消息处理程序
  - 幂等操作的特点是任意多次执行所产生的影响均与一次执行的影响相同。
- 跟踪消息并丢弃重复项
  - 当接收方处理消息时，将消息的 message id 作为创建和更新业务实体事务的一部分记录在数据表中。如果消息是重复的，则 insert 失败。接收方可以选择丢弃消息。

### 3.3.7 事务性消息

- 使用数据库表作为消息队列
- 通过轮询模式发布事件
- 使用事务日志拖尾模式发布事件

### 3.3.8 消息相关的类库和框架

- 二次封装，隐藏细节

## 3.4 使用异步消息提高可用性

### 3.4.1 同步消息会降低可用性

- REST：使用http通讯，客户端必须等待服务端返回。

### 3.4.2 消除同步交互

- 使用异步交互模式
  - 消息代理，类似消息队列。
- 复制数据
  - 服务维护一个数据副本，这些数据是在处理请求时需要使用的。这样在处理时，不用再额外的去请求数据
  - 如果数据副本大，会导致效率较低
  - 复制数据并没有从根本上解决服务如何更新其它服务所拥有的数据这个问题。
- 先返回响应，在完成处理
  - 缺点是客户端会相对更负责，比如创建订单，客户端需要轮询服务查询是否创建成功，从某种程度上也会加重服务器的负担。（是否可以订阅消息？这样又跟消息队列没啥区别了）



















